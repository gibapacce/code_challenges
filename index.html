<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fluxograma de Pensamento L√≥gico</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üß† Fluxograma de Pensamento L√≥gico</h1>
        <p>Visualiza√ß√£o do processo de resolu√ß√£o do problemas</p>
      </div>

      <div class="nav-container">
        <div class="problem-nav">
          <button
            class="nav-btn active"
            onclick="showFlowchart('palindrome-string')"
          >
            1. Valid Palindrome (String)
          </button>
          <button class="nav-btn" onclick="showFlowchart('two-sum')">
            2. Two Sum
          </button>
          <button class="nav-btn" onclick="showFlowchart('palindrome-number')">
            3. Palindrome Number
          </button>
          <button class="nav-btn" onclick="showFlowchart('missing-number-sum')">
            4. Missing Number (Soma)
          </button>
          <button class="nav-btn" onclick="showFlowchart('missing-number-xor')">
            5. Missing Number (XOR)
          </button>
          <button
            class="nav-btn"
            onclick="showFlowchart('missing-number-sort')"
          >
            6. Missing Number (Sort)
          </button>
          <button class="nav-btn" onclick="showFlowchart('merge-sorted')">
            7. Merge Sorted Array
          </button>
          <button class="nav-btn" onclick="showFlowchart('max-consecutive')">
            8. Max Consecutive Ones
          </button>
          <button class="nav-btn" onclick="showFlowchart('majority-element')">
            9. Majority Element
          </button>
          <button class="nav-btn" onclick="showFlowchart('intersection')">
            10. Intersection of Two Arrays
          </button>
          <button class="nav-btn" onclick="showFlowchart('first-bad-version')">
            11. First Bad Version
          </button>
          <button class="nav-btn" onclick="showFlowchart('fibonacci')">
            12. Fibonacci (Recursivo)
          </button>
          <button class="nav-btn" onclick="showFlowchart('contains-duplicate')">
            13. Contains Duplicate
          </button>
          <button class="nav-btn" onclick="showFlowchart('climbing-stairs')">
            14. Climbing Stairs
          </button>
          <button class="nav-btn" onclick="showFlowchart('binary-search')">
            15. Binary Search
          </button>
          <button class="nav-btn" onclick="showFlowchart('stock-profit')">
            16. Best Time to Buy and Sell Stock
          </button>
          <button class="nav-btn" onclick="showFlowchart('average-salary')">
            17. Average Salary Excluding Min and Max
          </button>
        </div>
      </div>

      <div class="content">
        <div id="palindrome-string" class="flowchart active">
          <h2>1. Valid Palindrome (String)</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              A phrase is a palindrome if, after converting all uppercase
              letters into lowercase letters and removing all non-alphanumeric
              characters, it reads the same forward and backward. Alphanumeric
              characters include letters and numbers.<br /><br />
              Given a string s, return true if it is a palindrome, or false
              otherwise.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: s = "A man, a plan, a canal: Panama"<br />Output:
                true</code
              ><br />
              Explanation: "amanaplanacanalpanama" is a palindrome.<br /><br />
              <strong>Example 2:</strong><br />
              <code>Input: s = "race a car"<br />Output: false</code><br />
              Explanation: "raceacar" is not a palindrome.<br /><br />
              <strong>Example 3:</strong><br />
              <code>Input: s = " "<br />Output: true</code><br />
              Explanation: s is an empty string "" after removing
              non-alphanumeric characters. Since an empty string reads the same
              forward and backward, it is a palindrome.<br /><br />
              <strong>Constraints:</strong><br />
              1 <= s.length <= 2 * 10<sup>5</sup><br />
              s consists only of printable ASCII characters.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo uma string e preciso verificar se √© pal√≠ndromo (igual
                  quando lida de tr√°s pra frente)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î AN√ÅLISE</h3>
                <p>
                  O que √© um pal√≠ndromo? Uma string que lida de tr√°s para frente
                  √© igual √† original. Mas preciso ignorar mai√∫sculas/min√∫sculas
                  e caracteres especiais.
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üßπ LIMPEZA</h3>
                <p>
                  1. Remover todos os caracteres n√£o alfanum√©ricos com regex<br />
                  2. Converter tudo para min√∫sculas
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ REVERS√ÉO</h3>
                <p>
                  Criar uma vers√£o invertida da string limpa usando split(),
                  reverse(), join()
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚öñÔ∏è COMPARA√á√ÉO</h3>
                <p>A string limpa √© igual √† sua vers√£o invertida?</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Se iguais ‚Üí true (√© pal√≠ndromo)<br />Se diferentes ‚Üí false
                  (n√£o √© pal√≠ndromo)
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre a string uma vez para limpar e uma vez para comparar
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Cria string filtrada e sua reversa
              </div>
            </div>
          </div>
        </div>

        <div id="two-sum" class="flowchart">
          <h2>2. Two Sum</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array of integers nums and an integer target, return
              indices of the two numbers such that they add up to target.<br /><br />
              You may assume that each input would have exactly one solution,
              and you may not use the same element twice.<br /><br />
              You can return the answer in any order.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: nums = [2,7,11,15], target = 9<br />Output: [0,1]</code
              ><br />
              Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].<br /><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [3,2,4], target = 6<br />Output: [1,2]</code
              ><br /><br />
              <strong>Example 3:</strong><br />
              <code>Input: nums = [3,3], target = 6<br />Output: [0,1]</code
              ><br /><br />
              <strong>Constraints:</strong><br />
              2 <= nums.length <= 10<sup>4</sup><br />
              -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup><br />
              -10<sup>9</sup> <= target <= 10<sup>9</sup><br />
              Only one valid answer exists.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo um array de n√∫meros e um target. Preciso encontrar dois
                  n√∫meros que somam o target.
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Se eu guardar os n√∫meros j√° vistos, posso verificar
                  rapidamente se o complemento j√° apareceu.
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üóÇÔ∏è ESTRUTURA</h3>
                <p>Criar um objeto (hash map) para mapear n√∫meros ‚Üí √≠ndices</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Para cada n√∫mero do array:<br />
                  1. Calcular complemento = target - n√∫mero atual<br />
                  2. Verificar se complemento j√° foi visto
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì ENCONTROU?</h3>
                <p>O complemento est√° no hash map?</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Se SIM ‚Üí retornar [√≠ndice do complemento, √≠ndice atual]<br />
                  Se N√ÉO ‚Üí guardar n√∫mero atual e continuar
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez, busca no hash map √© O(1)
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                No pior caso, armazena todos os n n√∫meros
              </div>
            </div>
          </div>
        </div>

        <div id="palindrome-number" class="flowchart">
          <h2>3. Palindrome Number</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an integer x, return true if x is a palindrome, and false
              otherwise.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: x = 121<br />Output: true</code><br />
              Explanation: 121 reads as 121 from left to right and from right to
              left.<br /><br />
              <strong>Example 2:</strong><br />
              <code>Input: x = -121<br />Output: false</code><br />
              Explanation: From left to right, it reads -121. From right to
              left, it becomes 121-. Therefore it is not a palindrome.<br /><br />
              <strong>Example 3:</strong><br />
              <code>Input: x = 10<br />Output: false</code><br />
              Explanation: Reads 01 from right to left. Therefore it is not a
              palindrome.<br /><br />
              <strong>Constraints:</strong><br />
              -2<sup>31</sup> <= x <= 2<sup>31</sup> - 1
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo um n√∫mero inteiro e preciso verificar se √© pal√≠ndromo
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>üö´ VERIFICA√á√ÉO INICIAL</h3>
                <p>
                  O n√∫mero √© negativo? Se sim, nunca √© pal√≠ndromo (por causa do
                  sinal '-')
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ CONVERS√ÉO</h3>
                <p>
                  Converter o n√∫mero para string para facilitar a manipula√ß√£o
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ REVERS√ÉO</h3>
                <p>
                  Criar vers√£o invertida da string usando split(), reverse(),
                  join()
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚öñÔ∏è COMPARA√á√ÉO</h3>
                <p>A string original √© igual √† invertida?</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Se iguais ‚Üí true (√© pal√≠ndromo)<br />Se diferentes ‚Üí false
                  (n√£o √© pal√≠ndromo)
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(k)</strong><br />
                k = n√∫mero de d√≠gitos do n√∫mero
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(k)</strong><br />
                Cria string e sua reversa
              </div>
            </div>
          </div>
        </div>

        <div id="missing-number-sum" class="flowchart">
          <h2>4. Missing Number (Soma)</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array nums containing n distinct numbers in the range [0,
              n], return the only number in the range that is missing from the
              array.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [3,0,1]<br />Output: 2</code><br />
              Explanation: n = 3 since there are 3 numbers, so all numbers are
              in the range [0,3]. 2 is the missing number in the range since it
              does not appear in nums.<br /><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [0,1]<br />Output: 2</code><br />
              Explanation: n = 2 since there are 2 numbers, so all numbers are
              in the range [0,2]. 2 is the missing number in the range since it
              does not appear in nums.<br /><br />
              <strong>Example 3:</strong><br />
              <code>Input: nums = [9,6,4,2,3,5,7,0,1]<br />Output: 8</code
              ><br />
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                  um n√∫mero
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î INSIGHT</h3>
                <p>
                  Se eu souber a soma esperada de 0 a n e subtrair a soma real,
                  encontro o n√∫mero ausente!
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üìê C√ÅLCULO ESPERADO</h3>
                <p>
                  Usar f√≥rmula da soma de PA: soma = n √ó (n + 1) √∑ 2<br />
                  onde n = tamanho do array
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚ûï SOMA REAL</h3>
                <p>Somar todos os elementos presentes no array</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚ûñ DIFEREN√áA</h3>
                <p>Calcular: soma_esperada - soma_real</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>A diferen√ßa √© o n√∫mero que est√° faltando!</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez para somar
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Usa apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <div id="missing-number-xor" class="flowchart">
          <h2>5. Missing Number (XOR)</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array nums containing n distinct numbers in the range [0,
              n], return the only number in the range that is missing from the
              array.<br /><br />
              Solve it using bitwise XOR.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [3,0,1]<br />Output: 2</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [0,1]<br />Output: 2</code><br />
              <strong>Example 3:</strong><br />
              <code>Input: nums = [9,6,4,2,3,5,7,0,1]<br />Output: 8</code
              ><br />
              <strong>Constraints:</strong><br />
              n == nums.length<br />
              1 <= n <= 10<sup>4</sup><br />
              0 <= nums[i] <= n<br />
              All the numbers of nums are unique.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                  um n√∫mero
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î INSIGHT</h3>
                <p>
                  Se eu aplicar XOR em todos os n√∫meros de 0 a n e em seguida
                  XOR em todos os elementos do array, o resultado ser√° o n√∫mero
                  que falta!
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚öôÔ∏è APLICA√á√ÉO DO XOR</h3>
                <p>
                  result = 0<br />
                  Para cada n√∫mero de 0 a n:<br />
                  - result ^= i<br />
                  Para cada elemento do array:<br />
                  - result ^= num
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Retornar o result, que √© o n√∫mero que falta</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array e a sequ√™ncia de 0 a n uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <div id="missing-number-sort" class="flowchart">
          <h2>6. Missing Number (Sort)</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array nums containing n distinct numbers in the range [0,
              n], return the only number in the range that is missing from the
              array.<br /><br />
              Solve it by first sorting the array.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [3,0,1]<br />Output: 2</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [0,1]<br />Output: 2</code><br />
              <strong>Example 3:</strong><br />
              <code>Input: nums = [9,6,4,2,3,5,7,0,1]<br />Output: 8</code
              ><br />
              <strong>Constraints:</strong><br />
              n == nums.length<br />
              1 <= n <= 10<sup>4</sup><br />
              0 <= nums[i] <= n<br />
              All the numbers of nums are unique.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                  um n√∫mero
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üì¶ ORDENA√á√ÉO</h3>
                <p>Ordenar o array em ordem crescente</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîç BUSCA PELO N√öMERO FALTANTE</h3>
                <p>Para i de 0 at√© array.length:</p>
                <pre>Se array[i] !== i, ent√£o o n√∫mero i est√° faltando</pre>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Retornar o n√∫mero que est√° faltando</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n log n)</strong><br />
                Devido √† ordena√ß√£o do array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Se a ordena√ß√£o for in-place
              </div>
            </div>
          </div>
        </div>

        <div id="merge-sorted" class="flowchart">
          <h2>7. Merge Sorted Array</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              You are given two integer arrays nums1 and nums2, sorted in
              non-decreasing order, and two integers m and n, representing the
              number of elements in nums1 and nums2 respectively.<br /><br />
              Merge nums2 into nums1 as one sorted array.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br />Output:
                [1,2,2,3,5,6]</code
              ><br />
              <strong>Example 2:</strong><br />
              <code
                >Input: nums1 = [1], m = 1, nums2 = [], n = 0<br />Output:
                [1]</code
              ><br />
              <strong>Constraints:</strong><br />
              nums1.length == m + n<br />
              nums2.length == n<br />
              0 <= m, n <= 200<br />
              1 <= m + n <= 200<br />
              -10<sup>9</sup> <= nums1[i], nums2[j] <= 10<sup>9</sup>
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso juntar dois arrays j√° ordenados em um s√≥, mantendo a
                  ordem
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Se eu comparar os menores elementos dispon√≠veis de cada array,
                  sempre posso escolher o menor!
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üëÜ PONTEIROS</h3>
                <p>
                  Criar dois ponteiros: um para cada array (i para nums1, j para
                  nums2)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ COMPARA√á√ÉO</h3>
                <p>
                  Enquanto ambos t√™m elementos:<br />
                  - Comparar nums1[i] com nums2[j]<br />
                  - Adicionar o menor ao resultado<br />
                  - Avan√ßar o ponteiro correspondente
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üßπ LIMPEZA</h3>
                <p>
                  Adicionar elementos restantes de nums1 e nums2 (se houver)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Copiar o resultado de volta para nums1</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(m + n)</strong><br />
                Percorre todos os elementos de ambos os arrays
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(m + n)</strong><br />
                Usa array auxiliar para o resultado
              </div>
            </div>
          </div>
        </div>

        <div id="max-consecutive" class="flowchart">
          <h2>8. Max Consecutive Ones</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given a binary array nums, return the maximum number of
              consecutive 1's in the array.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [1,1,0,1,1,1]<br />Output: 3</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [1,0,1,1,0,1]<br />Output: 2</code><br />
              <strong>Constraints:</strong><br />
              1 <= nums.length <= 10<sup>5</sup><br />
              nums[i] is either 0 or 1.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso encontrar o maior n√∫mero de 1s consecutivos em um
                  array de 0s e 1s
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Vou contar sequ√™ncias de 1s e sempre guardar a maior sequ√™ncia
                  vista at√© agora
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üìä CONTADORES</h3>
                <p>
                  currCount = 0 (sequ√™ncia atual)<br />
                  maxCount = 0 (maior sequ√™ncia)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Para cada elemento do array:<br />
                  - Se for 1: currCount++<br />
                  - Se for 0: atualizar maxCount e zerar currCount
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì FINAL DO ARRAY</h3>
                <p>E se a maior sequ√™ncia terminar no √∫ltimo elemento?</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Retornar Math.max(maxCount, currCount) para garantir que n√£o
                  perdemos a √∫ltima sequ√™ncia
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <div id="majority-element" class="flowchart">
          <h2>9. Majority Element</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array nums of size n, return the majority element.<br /><br />
              The majority element is the element that appears more than ‚åän / 2‚åã
              times. You may assume that the majority element always exists in
              the array.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [3,2,3]<br />Output: 3</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [2,2,1,1,1,2,2]<br />Output: 2</code><br />
              <strong>Constraints:</strong><br />
              n == nums.length<br />
              1 <= n <= 5 * 10<sup>4</sup><br />
              -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ INICIO</h3>
                <p>
                  Encontrar o elemento que aparece mais da metade das vezes no
                  array
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î INSIGHT</h3>
                <p>
                  Se um elemento aparece mais da metade das vezes, ap√≥s ordenar
                  o array, ele SEMPRE estar√° na posi√ß√£o do meio!
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üìä ORDENA√á√ÉO</h3>
                <p>Ordenar o array em ordem crescente</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üéØ MEIO</h3>
                <p>Calcular o √≠ndice do meio: Math.floor(nums.length / 2)</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  O elemento na posi√ß√£o do meio √© obrigatoriamente o
                  majorit√°rio!
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n log n)</strong><br />
                Devido √† ordena√ß√£o do array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Se ordena√ß√£o for in-place
              </div>
            </div>
          </div>
        </div>

        <div id="intersection" class="flowchart">
          <h2>10. Intersection of Two Arrays</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given two integer arrays nums1 and nums2, return an array of their
              intersection. Each element in the result must be unique and you
              may return the result in any order.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: nums1 = [1,2,2,1], nums2 = [2,2]<br />Output: [2]</code
              ><br />
              <strong>Example 2:</strong><br />
              <code
                >Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br />Output:
                [9,4]</code
              ><br />
              <strong>Constraints:</strong><br />
              1 <= nums1.length, nums2.length <= 1000<br />
              0 <= nums1[i], nums2[i] <= 1000
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso encontrar elementos que aparecem em ambos os arrays
                  (sem duplicatas)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Se eu guardar elementos do primeiro array em um Set, posso
                  verificar rapidamente se um elemento do segundo est√° presente
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üóÇÔ∏è SET</h3>
                <p>Criar um Set com todos os elementos √∫nicos de nums1</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ VERIFICA√á√ÉO</h3>
                <p>
                  Para cada elemento de nums2:<br />
                  - Verificar se est√° no Set<br />
                  - Se sim: adicionar ao resultado e remover do Set
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì POR QUE REMOVER?</h3>
                <p>Removemos do Set para evitar duplicatas no resultado!</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Array com elementos comuns, sem duplicatas</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n + m)</strong><br />
                n = nums1.length, m = nums2.length
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Para armazenar o Set de nums1
              </div>
            </div>
          </div>
        </div>

        <div id="first-bad-version" class="flowchart">
          <h2>11. First Bad Version</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              You are a product manager and currently leading a team to develop
              a new product. Unfortunately, the latest version of your product
              fails the quality check. Since each version is developed based on
              the previous version, all the versions after a bad version are
              also bad.<br /><br />
              Suppose you have n versions [1, 2, ..., n] and you want to find
              out the first bad one, which causes all the following ones to be
              bad.<br /><br />
              You are given an API bool isBadVersion(version) which returns
              whether version is bad. Implement a function to find the first bad
              version. You should minimize the number of calls to the API.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: n = 5, bad = 4<br />Output: 4</code><br />
              <strong>Constraints:</strong><br />
              1 <= bad <= n <= 2<sup>31</sup> - 1
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso encontrar a primeira vers√£o ruim, minimizando chamadas
                  √† API isBadVersion
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î INSIGHT</h3>
                <p>
                  Se uma vers√£o √© ruim, todas as seguintes tamb√©m s√£o. √â uma
                  transi√ß√£o ordenada: bom ‚Üí ruim
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üéØ BUSCA BIN√ÅRIA</h3>
                <p>Usar ponteiros left = 1, right = n</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Enquanto left < right:<br />
                  - mid = (left + right) / 2<br />
                  - Testar isBadVersion(mid)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì √â RUIM?</h3>
                <p>
                  Se isBadVersion(mid) == true:<br />
                  - A primeira vers√£o ruim est√° em mid ou antes<br />
                  - right = mid<br /><br />
                  Se false:<br />
                  - A primeira vers√£o ruim est√° depois<br />
                  - left = mid + 1
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Quando left == right, encontramos a primeira vers√£o ruim!</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(log n)</strong><br />
                Busca bin√°ria reduz pela metade a cada itera√ß√£o
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <div id="fibonacci" class="flowchart">
          <h2>12. Fibonacci (Recursivo)</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              The Fibonacci numbers, commonly denoted F(n) form a sequence,
              called the Fibonacci sequence, such that each number is the sum of
              the two preceding ones, starting from 0 and 1. That is,<br />
              F(0) = 0, F(1) = 1<br />
              F(n) = F(n - 1) + F(n - 2), for n > 1.<br /><br />
              Given n, calculate F(n).<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: n = 2<br />Output: 1</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: n = 3<br />Output: 2</code><br />
              <strong>Example 3:</strong><br />
              <code>Input: n = 4<br />Output: 3</code><br />
              <strong>Constraints:</strong><br />
              0 <= n <= 30
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso calcular o n-√©simo n√∫mero de Fibonacci: F(n) = F(n-1)
                  + F(n-2)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î DEFINI√á√ÉO</h3>
                <p>
                  Fibonacci: cada n√∫mero √© a soma dos dois anteriores<br />
                  F(0) = 0, F(1) = 1, F(2) = 1, F(3) = 2, F(4) = 3...
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üõë CASO BASE</h3>
                <p>
                  Se n == 0 ou n == 1:<br />
                  Retornar n (F(0) = 0, F(1) = 1)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ RECURS√ÉO</h3>
                <p>
                  Para n > 1:<br />
                  Retornar fib(n-1) + fib(n-2)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ö†Ô∏è PROBLEMA</h3>
                <p>Muitas recomputa√ß√µes! fib(5) calcula fib(3) v√°rias vezes</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Funciona, mas ineficiente. Alternativa: bottom-up ou
                  memoiza√ß√£o
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(2^n)</strong><br />
                Muitas recomputa√ß√µes recursivas
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Profundidade da pilha de chamadas
              </div>
            </div>
          </div>
        </div>

        <div id="contains-duplicate" class="flowchart">
          <h2>13. Contains Duplicate</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an integer array nums, return true if any value appears at
              least twice in the array, and return false if every element is
              distinct.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: nums = [1,2,3,1]<br />Output: true</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: nums = [1,2,3,4]<br />Output: false</code><br />
              <strong>Example 3:</strong><br />
              <code>Input: nums = [1,1,1,3,3,4,3,2,4,2]<br />Output: true</code
              ><br />
              <strong>Constraints:</strong><br />
              1 <= nums.length <= 10<sup>5</sup><br />
              -10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso verificar se existe algum n√∫mero duplicado no array
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Se eu guardar os n√∫meros j√° vistos, posso verificar
                  rapidamente se j√° vi o n√∫mero atual
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üóÇÔ∏è SET</h3>
                <p>Criar um Set vazio para armazenar n√∫meros j√° vistos</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Para cada n√∫mero do array:<br />
                  1. Verificar se j√° est√° no Set<br />
                  2. Se sim ‚Üí encontrou duplicado!<br />
                  3. Se n√£o ‚Üí adicionar ao Set
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì ENCONTROU?</h3>
                <p>
                  Se encontrou duplicado ‚Üí return true<br />
                  Se n√£o encontrou ‚Üí continuar
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Se terminou o loop sem encontrar ‚Üí return false</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez, Set.has() √© O(1)
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                No pior caso, todos elementos √∫nicos
              </div>
            </div>
          </div>
        </div>

        <div id="climbing-stairs" class="flowchart">
          <h2>14. Climbing Stairs</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              You are climbing a staircase. It takes n steps to reach the
              top.<br /><br />
              Each time you can either climb 1 or 2 steps. In how many distinct
              ways can you climb to the top?<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: n = 2<br />Output: 2</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: n = 3<br />Output: 3</code><br />
              <strong>Constraints:</strong><br />
              1 <= n <= 45
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso contar quantas maneiras existem de subir n degraus (1
                  ou 2 por vez)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î INSIGHT</h3>
                <p>
                  Para chegar ao degrau n, posso vir do degrau n-1 (subindo 1)
                  ou do n-2 (subindo 2)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üìê F√ìRMULA</h3>
                <p>
                  ways(n) = ways(n-1) + ways(n-2)<br />
                  √â como Fibonacci!
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üõë CASOS BASE</h3>
                <p>
                  n = 1 ‚Üí 1 maneira<br />
                  n = 2 ‚Üí 2 maneiras (1+1 ou 2)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ BOTTOM-UP</h3>
                <p>
                  Para n ‚â• 3:<br />
                  - oneStepBefore = 2 (ways para n-1)<br />
                  - twoStepsBefore = 1 (ways para n-2)<br />
                  - Calcular ways = oneStepBefore + twoStepsBefore
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Retornar o n√∫mero total de maneiras calculado</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre de 3 at√© n uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <div id="binary-search" class="flowchart">
          <h2>15. Binary Search</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              Given an array of integers nums which is sorted in ascending
              order, and an integer target, write a function to search target in
              nums. If target exists, then return its index. Otherwise, return
              -1.<br /><br />
              You must write an algorithm with O(log n) runtime complexity.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: nums = [-1,0,3,5,9,12], target = 9<br />Output: 4</code
              ><br />
              <strong>Example 2:</strong><br />
              <code
                >Input: nums = [-1,0,3,5,9,12], target = 2<br />Output: -1</code
              ><br />
              <strong>Constraints:</strong><br />
              1 <= nums.length <= 10<sup>4</sup><br />
              -10<sup>4</sup> < nums[i], target < 10<sup>4</sup><br />
              All the integers in nums are unique.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso encontrar rapidamente um elemento em um array ordenado
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î VANTAGEM</h3>
                <p>
                  Array est√° ordenado! Posso descartar metade dos elementos a
                  cada compara√ß√£o
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üëÜ PONTEIROS</h3>
                <p>
                  left = 0 (in√≠cio do array)<br />
                  right = nums.length - 1 (fim do array)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Enquanto left ‚â§ right:<br />
                  1. mid = (left + right) / 2<br />
                  2. Comparar nums[mid] com target
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>‚ùì COMPARA√á√ÉO</h3>
                <p>
                  Se nums[mid] == target ‚Üí encontrou!<br />
                  Se nums[mid] < target ‚Üí left = mid + 1<br />
                  Se nums[mid] > target ‚Üí right = mid - 1
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>
                  Se encontrou ‚Üí retornar √≠ndice<br />
                  Se n√£o encontrou ‚Üí retornar -1
                </p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(log n)</strong><br />
                Descarta metade a cada itera√ß√£o
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <div id="stock-profit" class="flowchart">
          <h2>16. Best Time to Buy and Sell Stock</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              You are given an array prices where prices[i] is the price of a
              given stock on the i-th day.<br /><br />
              You want to maximize your profit by choosing a single day to buy
              one stock and choosing a different day in the future to sell that
              stock. Return the maximum profit you can achieve from this
              transaction. If you cannot achieve any profit, return 0.<br /><br />
              <strong>Example 1:</strong><br />
              <code>Input: prices = [7,1,5,3,6,4]<br />Output: 5</code><br />
              <strong>Example 2:</strong><br />
              <code>Input: prices = [7,6,4,3,1]<br />Output: 0</code><br />
              <strong>Constraints:</strong><br />
              1 <= prices.length <= 10<sup>5</sup><br />
              0 <= prices[i] <= 10<sup>4</sup>
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso calcular o lucro m√°ximo comprando e vendendo uma a√ß√£o
                  (comprar antes de vender)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Quero comprar no menor pre√ßo poss√≠vel e vender no maior pre√ßo
                  DEPOIS disso
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üìä VARI√ÅVEIS</h3>
                <p>
                  minPrice = Infinity (menor pre√ßo visto)<br />
                  maxProfit = 0 (maior lucro poss√≠vel)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîÑ ITERA√á√ÉO</h3>
                <p>
                  Para cada pre√ßo no array:<br />
                  1. Atualizar minPrice se pre√ßo atual for menor<br />
                  2. Calcular lucro se vendesse hoje<br />
                  3. Atualizar maxProfit se lucro for maior
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>üí° L√ìGICA</h3>
                <p>
                  A cada dia, pergunto:<br />
                  "Esse √© o melhor dia para comprar?" ou<br />
                  "Esse √© o melhor dia para vender?"
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Retornar o maxProfit calculado</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <div id="average-salary" class="flowchart">
          <h2>17. Average Salary Excluding Min and Max</h2>
          <div class="problem-flow-grid">
            <div class="problem-summary complexity-box">
              <strong>Problema:</strong><br />
              You are given an array of unique integers salary where salary[i]
              is the salary of the i-th employee.<br /><br />
              Return the average salary of employees excluding the minimum and
              maximum salary. Answers within 10<sup>-5</sup> of the actual
              answer will be accepted.<br /><br />
              <strong>Example 1:</strong><br />
              <code
                >Input: salary = [4000,3000,1000,2000]<br />Output:
                2500.00000</code
              ><br />
              <strong>Example 2:</strong><br />
              <code
                >Input: salary = [1000,2000,3000]<br />Output: 2000.00000</code
              ><br />
              <strong>Constraints:</strong><br />
              3 <= salary.length <= 100<br />
              1000 <= salary[i] <= 10<sup>6</sup><br />
              All the integers of salary are unique.
            </div>
            <div class="flow-container">
              <div class="flow-step start">
                <h3>üéØ IN√çCIO</h3>
                <p>
                  Preciso calcular a m√©dia salarial excluindo o menor e o maior
                  sal√°rio
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step decision">
                <h3>ü§î ESTRAT√âGIA</h3>
                <p>
                  Vou encontrar min e max, somar todos os sal√°rios, subtrair min
                  e max, e dividir pelo restante
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>üîç ENCONTRAR MIN/MAX</h3>
                <p>
                  minSalary = Math.min(...salary)<br />
                  maxSalary = Math.max(...salary)
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚ûï SOMA TOTAL</h3>
                <p>totalSum = salary.reduce((acc, val) => acc + val, 0)</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚ûñ EXCLUIR MIN/MAX</h3>
                <p>sumWithoutMinMax = totalSum - minSalary - maxSalary</p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step process">
                <h3>‚ûó CALCULAR M√âDIA</h3>
                <p>
                  count = salary.length - 2<br />
                  average = sumWithoutMinMax / count
                </p>
              </div>
              <div class="arrow"></div>
              <div class="flow-step end">
                <h3>‚úÖ RESULTADO</h3>
                <p>Retornar a m√©dia calculada</p>
              </div>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                min, max e reduce percorrem o array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      function showFlowchart(id) {
        // Esconder todos os fluxogramas
        const flowcharts = document.querySelectorAll(".flowchart");
        flowcharts.forEach((chart) => chart.classList.remove("active"));

        // Mostrar o fluxograma selecionado
        document.getElementById(id).classList.add("active");

        // Atualizar bot√µes de navega√ß√£o
        const buttons = document.querySelectorAll(".nav-btn");
        buttons.forEach((btn) => btn.classList.remove("active"));
        event.target.classList.add("active");

        // Scroll suave para o topo do conte√∫do
        document.querySelector(".content").scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      }
    </script>
  </body>
</html>
