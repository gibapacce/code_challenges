<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fluxogramas de Pensamento L√≥gico</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üß† Fluxogramas de Pensamento L√≥gico</h1>
        <p>Visualiza√ß√£o do processo de resolu√ß√£o dos problemas</p>
      </div>

      <div class="nav-container">
        <div class="problem-nav">
          <button
            class="nav-btn active"
            onclick="showFlowchart('palindrome-string')"
          >
            1. Valid Palindrome (String)
          </button>
          <button class="nav-btn" onclick="showFlowchart('two-sum')">
            2. Two Sum
          </button>
          <button class="nav-btn" onclick="showFlowchart('palindrome-number')">
            3. Palindrome Number
          </button>
          <button class="nav-btn" onclick="showFlowchart('missing-number-sum')">
            4. Missing Number (Soma)
          </button>
          <button class="nav-btn" onclick="showFlowchart('missing-number-xor')">
            5. Missing Number (XOR)
          </button>
          <button
            class="nav-btn"
            onclick="showFlowchart('missing-number-sort')"
          >
            6. Missing Number (Sort)
          </button>
          <button class="nav-btn" onclick="showFlowchart('merge-sorted')">
            7. Merge Sorted Array
          </button>
          <button class="nav-btn" onclick="showFlowchart('max-consecutive')">
            8. Max Consecutive Ones
          </button>
          <button class="nav-btn" onclick="showFlowchart('majority-element')">
            9. Majority Element
          </button>
          <button class="nav-btn" onclick="showFlowchart('intersection')">
            10. Intersection of Two Arrays
          </button>
          <button class="nav-btn" onclick="showFlowchart('first-bad-version')">
            11. First Bad Version
          </button>
          <button class="nav-btn" onclick="showFlowchart('fibonacci')">
            12. Fibonacci (Recursivo)
          </button>
          <button class="nav-btn" onclick="showFlowchart('contains-duplicate')">
            13. Contains Duplicate
          </button>
          <button class="nav-btn" onclick="showFlowchart('climbing-stairs')">
            14. Climbing Stairs
          </button>
          <button class="nav-btn" onclick="showFlowchart('binary-search')">
            15. Binary Search
          </button>
          <button class="nav-btn" onclick="showFlowchart('stock-profit')">
            16. Best Time to Buy and Sell Stock
          </button>
          <button class="nav-btn" onclick="showFlowchart('average-salary')">
            17. Average Salary Excluding Min and Max
          </button>
        </div>
      </div>

      <div class="content">
        <!-- 1. Valid Palindrome -->
        <div id="palindrome-string" class="flowchart active">
          <h2>1. Valid Palindrome (String)</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba uma string e determine se ela √© um
            pal√≠ndromo, ou seja, se pode ser lida da mesma forma de tr√°s para
            frente. Para isso, desconsidere diferen√ßas entre mai√∫sculas e
            min√∫sculas, al√©m de ignorar todos os caracteres que n√£o sejam letras
            ou n√∫meros. O objetivo √© retornar <code>true</code> se a string for
            um pal√≠ndromo v√°lido e <code>false</code> caso contr√°rio.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo uma string e preciso verificar se √© pal√≠ndromo (igual
                quando lida de tr√°s pra frente)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î AN√ÅLISE</h3>
              <p>
                O que √© um pal√≠ndromo? Uma string que lida de tr√°s para frente √©
                igual √† original. Mas preciso ignorar mai√∫sculas/min√∫sculas e
                caracteres especiais.
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üßπ LIMPEZA</h3>
              <p>
                1. Remover todos os caracteres n√£o alfanum√©ricos com regex<br />
                2. Converter tudo para min√∫sculas
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ REVERS√ÉO</h3>
              <p>
                Criar uma vers√£o invertida da string limpa usando split(),
                reverse(), join()
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚öñÔ∏è COMPARA√á√ÉO</h3>
              <p>A string limpa √© igual √† sua vers√£o invertida?</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Se iguais ‚Üí true (√© pal√≠ndromo)<br />Se diferentes ‚Üí false (n√£o
                √© pal√≠ndromo)
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre a string uma vez para limpar e uma vez para comparar
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Cria string filtrada e sua reversa
              </div>
            </div>
          </div>
        </div>

        <!-- 2. Two Sum -->
        <div id="two-sum" class="flowchart">
          <h2>2. Two Sum</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um array de inteiros e um valor alvo
            (<code>target</code>), encontre dois n√∫meros no array cuja soma seja
            exatamente igual ao alvo. Retorne os √≠ndices desses dois n√∫meros.
            Cada entrada ter√° exatamente uma solu√ß√£o e n√£o √© permitido usar o
            mesmo elemento duas vezes.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo um array de n√∫meros e um target. Preciso encontrar dois
                n√∫meros que somam o target.
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Se eu guardar os n√∫meros j√° vistos, posso verificar rapidamente
                se o complemento j√° apareceu.
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üóÇÔ∏è ESTRUTURA</h3>
              <p>Criar um objeto (hash map) para mapear n√∫meros ‚Üí √≠ndices</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Para cada n√∫mero do array:<br />
                1. Calcular complemento = target - n√∫mero atual<br />
                2. Verificar se complemento j√° foi visto
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì ENCONTROU?</h3>
              <p>O complemento est√° no hash map?</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Se SIM ‚Üí retornar [√≠ndice do complemento, √≠ndice atual]<br />
                Se N√ÉO ‚Üí guardar n√∫mero atual e continuar
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez, busca no hash map √© O(1)
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                No pior caso, armazena todos os n n√∫meros
              </div>
            </div>
          </div>
        </div>

        <!-- 3. Palindrome Number -->
        <div id="palindrome-number" class="flowchart">
          <h2>3. Palindrome Number</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um n√∫mero inteiro e verifique se
            ele √© um pal√≠ndromo, ou seja, se a sua representa√ß√£o decimal √© igual
            quando lida da esquerda para a direita e da direita para a esquerda.
            N√∫meros negativos nunca s√£o considerados pal√≠ndromos.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo um n√∫mero inteiro e preciso verificar se √© pal√≠ndromo
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>üö´ VERIFICA√á√ÉO INICIAL</h3>
              <p>
                O n√∫mero √© negativo? Se sim, nunca √© pal√≠ndromo (por causa do
                sinal '-')
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ CONVERS√ÉO</h3>
              <p>Converter o n√∫mero para string para facilitar a manipula√ß√£o</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ REVERS√ÉO</h3>
              <p>
                Criar vers√£o invertida da string usando split(), reverse(),
                join()
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚öñÔ∏è COMPARA√á√ÉO</h3>
              <p>A string original √© igual √† invertida?</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Se iguais ‚Üí true (√© pal√≠ndromo)<br />Se diferentes ‚Üí false (n√£o
                √© pal√≠ndromo)
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(k)</strong><br />
                k = n√∫mero de d√≠gitos do n√∫mero
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(k)</strong><br />
                Cria string e sua reversa
              </div>
            </div>
          </div>
        </div>

        <!-- 4. Missing Number (Soma) -->
        <div id="missing-number-sum" class="flowchart">
          <h2>4. Missing Number (Soma)</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um array contendo
            <code>n</code> n√∫meros distintos no intervalo de <code>0</code> a
            <code>n</code>, encontre qual n√∫mero est√° faltando na sequ√™ncia. O
            array possui exatamente um n√∫mero ausente e nenhum valor duplicado.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                um n√∫mero
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î INSIGHT</h3>
              <p>
                Se eu souber a soma esperada de 0 a n e subtrair a soma real,
                encontro o n√∫mero ausente!
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üìê C√ÅLCULO ESPERADO</h3>
              <p>
                Usar f√≥rmula da soma de PA: soma = n √ó (n + 1) √∑ 2<br />
                onde n = tamanho do array
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚ûï SOMA REAL</h3>
              <p>Somar todos os elementos presentes no array</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚ûñ DIFEREN√áA</h3>
              <p>Calcular: soma_esperada - soma_real</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>A diferen√ßa √© o n√∫mero que est√° faltando!</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez para somar
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Usa apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <!-- 5. Missing Number (XOR) -->
        <div id="missing-number-xor" class="flowchart">
          <h2>5. Missing Number (XOR)</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um array com <code>n</code> n√∫meros
            distintos de <code>0</code> a <code>n</code>, encontre o n√∫mero
            ausente utilizando opera√ß√µes de XOR. O objetivo √© identificar o
            √∫nico valor do intervalo que n√£o est√° presente no array.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                um n√∫mero
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î INSIGHT</h3>
              <p>
                Se eu aplicar XOR em todos os n√∫meros de 0 a n e em seguida XOR
                em todos os elementos do array, o resultado ser√° o n√∫mero que
                falta!
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚öôÔ∏è APLICA√á√ÉO DO XOR</h3>
              <p>
                result = 0<br />
                Para cada n√∫mero de 0 a n:<br />
                - result ^= i<br />
                Para cada elemento do array:<br />
                - result ^= num
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Retornar o result, que √© o n√∫mero que falta</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array e a sequ√™ncia de 0 a n uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <!-- 6. Missing Number (Sort) -->
        <div id="missing-number-sort" class="flowchart">
          <h2>6. Missing Number (Sort)</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um array de <code>n</code> n√∫meros
            distintos de <code>0</code> a <code>n</code> e encontre o n√∫mero
            ausente, utilizando ordena√ß√£o para facilitar a busca. O array deve
            conter todos os n√∫meros do intervalo, exceto um.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Recebo um array que deveria conter n√∫meros de 0 a n, mas falta
                um n√∫mero
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üì¶ ORDENA√á√ÉO</h3>
              <p>Ordenar o array em ordem crescente</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîç BUSCA PELO N√öMERO FALTANTE</h3>
              <p>Para i de 0 at√© array.length:</p>
              <pre>Se array[i] !== i, ent√£o o n√∫mero i est√° faltando</pre>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Retornar o n√∫mero que est√° faltando</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n log n)</strong><br />
                Devido √† ordena√ß√£o do array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Se a ordena√ß√£o for in-place
              </div>
            </div>
          </div>
        </div>

        <!-- 7. Merge Sorted Array -->
        <div id="merge-sorted" class="flowchart">
          <h2>7. Merge Sorted Array</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado dois arrays de inteiros j√° ordenados
            em ordem crescente, mescle-os em um √∫nico array tamb√©m ordenado. O
            objetivo √© combinar os elementos mantendo a ordem crescente, podendo
            utilizar arrays auxiliares ou ponteiros.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso juntar dois arrays j√° ordenados em um s√≥, mantendo a
                ordem
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Se eu comparar os menores elementos dispon√≠veis de cada array,
                sempre posso escolher o menor!
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üëÜ PONTEIROS</h3>
              <p>
                Criar dois ponteiros: um para cada array (i para nums1, j para
                nums2)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ COMPARA√á√ÉO</h3>
              <p>
                Enquanto ambos t√™m elementos:<br />
                - Comparar nums1[i] com nums2[j]<br />
                - Adicionar o menor ao resultado<br />
                - Avan√ßar o ponteiro correspondente
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üßπ LIMPEZA</h3>
              <p>Adicionar elementos restantes de nums1 e nums2 (se houver)</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Copiar o resultado de volta para nums1</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(m + n)</strong><br />
                Percorre todos os elementos de ambos os arrays
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(m + n)</strong><br />
                Usa array auxiliar para o resultado
              </div>
            </div>
          </div>
        </div>

        <!-- 8. Max Consecutive Ones -->
        <div id="max-consecutive" class="flowchart">
          <h2>8. Max Consecutive Ones</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um array composto apenas por
            <code>0</code>s e <code>1</code>s e determine o maior n√∫mero de
            <code>1</code>s consecutivos presentes em qualquer sequ√™ncia do
            array. O objetivo √© retornar o comprimento da maior sequ√™ncia
            cont√≠nua de <code>1</code>s.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso encontrar o maior n√∫mero de 1s consecutivos em um array
                de 0s e 1s
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Vou contar sequ√™ncias de 1s e sempre guardar a maior sequ√™ncia
                vista at√© agora
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üìä CONTADORES</h3>
              <p>
                currCount = 0 (sequ√™ncia atual)<br />
                maxCount = 0 (maior sequ√™ncia)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Para cada elemento do array:<br />
                - Se for 1: currCount++<br />
                - Se for 0: atualizar maxCount e zerar currCount
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì FINAL DO ARRAY</h3>
              <p>E se a maior sequ√™ncia terminar no √∫ltimo elemento?</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Retornar Math.max(maxCount, currCount) para garantir que n√£o
                perdemos a √∫ltima sequ√™ncia
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <!-- 9. Majority Element -->
        <div id="majority-element" class="flowchart">
          <h2>9. Majority Element</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um array de inteiros, encontre o
            elemento que aparece mais da metade das vezes no array (ou seja, em
            mais de <code>n/2</code> posi√ß√µes). Sempre existir√° um elemento
            majorit√°rio.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ INICIO</h3>
              <p>
                Encontrar o elemento que aparece mais da metade das vezes no
                array
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î INSIGHT</h3>
              <p>
                Se um elemento aparece mais da metade das vezes, ap√≥s ordenar o
                array, ele SEMPRE estar√° na posi√ß√£o do meio!
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üìä ORDENA√á√ÉO</h3>
              <p>Ordenar o array em ordem crescente</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üéØ MEIO</h3>
              <p>Calcular o √≠ndice do meio: Math.floor(nums.length / 2)</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                O elemento na posi√ß√£o do meio √© obrigatoriamente o majorit√°rio!
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n log n)</strong><br />
                Devido √† ordena√ß√£o do array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Se ordena√ß√£o for in-place
              </div>
            </div>
          </div>
        </div>

        <!-- 10. Intersection of Arrays -->
        <div id="intersection" class="flowchart">
          <h2>10. Intersection of Two Arrays</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba dois arrays de inteiros e retorne
            um novo array contendo apenas os elementos que aparecem em ambos,
            sem repeti√ß√µes. O resultado n√£o deve conter duplicatas, mesmo que os
            elementos se repitam nos arrays de entrada.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso encontrar elementos que aparecem em ambos os arrays (sem
                duplicatas)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Se eu guardar elementos do primeiro array em um Set, posso
                verificar rapidamente se um elemento do segundo est√° presente
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üóÇÔ∏è SET</h3>
              <p>Criar um Set com todos os elementos √∫nicos de nums1</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ VERIFICA√á√ÉO</h3>
              <p>
                Para cada elemento de nums2:<br />
                - Verificar se est√° no Set<br />
                - Se sim: adicionar ao resultado e remover do Set
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì POR QUE REMOVER?</h3>
              <p>Removemos do Set para evitar duplicatas no resultado!</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Array com elementos comuns, sem duplicatas</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n + m)</strong><br />
                n = nums1.length, m = nums2.length
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Para armazenar o Set de nums1
              </div>
            </div>
          </div>
        </div>

        <!-- 9. First Bad Version -->
        <div id="first-bad-version" class="flowchart">
          <h2>9. First Bad Version</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado <code>n</code> vers√µes de um produto
            e uma fun√ß√£o <code>isBadVersion</code> que identifica se uma vers√£o
            √© "ruim", encontre a primeira vers√£o ruim minimizando o n√∫mero de
            chamadas √† API. Todas as vers√µes ap√≥s a primeira ruim tamb√©m s√£o
            ruins.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso encontrar a primeira vers√£o ruim, minimizando chamadas √†
                API isBadVersion
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î INSIGHT</h3>
              <p>
                Se uma vers√£o √© ruim, todas as seguintes tamb√©m s√£o. √â uma
                transi√ß√£o ordenada: bom ‚Üí ruim
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üéØ BUSCA BIN√ÅRIA</h3>
              <p>Usar ponteiros left = 1, right = n</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Enquanto left < right:<br />
                - mid = (left + right) / 2<br />
                - Testar isBadVersion(mid)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì √â RUIM?</h3>
              <p>
                Se isBadVersion(mid) == true:<br />
                - A primeira vers√£o ruim est√° em mid ou antes<br />
                - right = mid<br /><br />
                Se false:<br />
                - A primeira vers√£o ruim est√° depois<br />
                - left = mid + 1
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Quando left == right, encontramos a primeira vers√£o ruim!</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(log n)</strong><br />
                Busca bin√°ria reduz pela metade a cada itera√ß√£o
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <!-- 10. Fibonacci -->
        <div id="fibonacci" class="flowchart">
          <h2>10. Fibonacci (Recursivo)</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um n√∫mero <code>n</code>, calcule o
            n-√©simo termo da sequ√™ncia de Fibonacci utilizando recurs√£o. A
            sequ√™ncia come√ßa com F(0) = 0 e F(1) = 1, e cada termo seguinte √© a
            soma dos dois anteriores.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso calcular o n-√©simo n√∫mero de Fibonacci: F(n) = F(n-1) +
                F(n-2)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î DEFINI√á√ÉO</h3>
              <p>
                Fibonacci: cada n√∫mero √© a soma dos dois anteriores<br />
                F(0) = 0, F(1) = 1, F(2) = 1, F(3) = 2, F(4) = 3...
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üõë CASO BASE</h3>
              <p>
                Se n == 0 ou n == 1:<br />
                Retornar n (F(0) = 0, F(1) = 1)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ RECURS√ÉO</h3>
              <p>
                Para n > 1:<br />
                Retornar fib(n-1) + fib(n-2)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ö†Ô∏è PROBLEMA</h3>
              <p>Muitas recomputa√ß√µes! fib(5) calcula fib(3) v√°rias vezes</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Funciona, mas ineficiente. Alternativa: bottom-up ou memoiza√ß√£o
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(2^n)</strong><br />
                Muitas recomputa√ß√µes recursivas
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                Profundidade da pilha de chamadas
              </div>
            </div>
          </div>
        </div>

        <!-- 11. Contains Duplicate -->
        <div id="contains-duplicate" class="flowchart">
          <h2>11. Contains Duplicate</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um array de inteiros e determine se
            existe algum valor que aparece pelo menos duas vezes. O objetivo √©
            retornar <code>true</code> se houver duplicados e
            <code>false</code> caso todos os elementos sejam √∫nicos.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>Preciso verificar se existe algum n√∫mero duplicado no array</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Se eu guardar os n√∫meros j√° vistos, posso verificar rapidamente
                se j√° vi o n√∫mero atual
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üóÇÔ∏è SET</h3>
              <p>Criar um Set vazio para armazenar n√∫meros j√° vistos</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Para cada n√∫mero do array:<br />
                1. Verificar se j√° est√° no Set<br />
                2. Se sim ‚Üí encontrou duplicado!<br />
                3. Se n√£o ‚Üí adicionar ao Set
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì ENCONTROU?</h3>
              <p>
                Se encontrou duplicado ‚Üí return true<br />
                Se n√£o encontrou ‚Üí continuar
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Se terminou o loop sem encontrar ‚Üí return false</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez, Set.has() √© O(1)
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(n)</strong><br />
                No pior caso, todos elementos √∫nicos
              </div>
            </div>
          </div>
        </div>

        <!-- 12. Climbing Stairs -->
        <div id="climbing-stairs" class="flowchart">
          <h2>12. Climbing Stairs</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um n√∫mero
            <code>n</code> representando a quantidade de degraus de uma escada,
            calcule de quantas maneiras diferentes √© poss√≠vel chegar ao topo,
            podendo subir 1 ou 2 degraus por vez. O objetivo √© retornar o total
            de combina√ß√µes poss√≠veis.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso contar quantas maneiras existem de subir n degraus (1 ou
                2 por vez)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î INSIGHT</h3>
              <p>
                Para chegar ao degrau n, posso vir do degrau n-1 (subindo 1) ou
                do n-2 (subindo 2)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üìê F√ìRMULA</h3>
              <p>
                ways(n) = ways(n-1) + ways(n-2)<br />
                √â como Fibonacci!
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üõë CASOS BASE</h3>
              <p>
                n = 1 ‚Üí 1 maneira<br />
                n = 2 ‚Üí 2 maneiras (1+1 ou 2)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ BOTTOM-UP</h3>
              <p>
                Para n ‚â• 3:<br />
                - oneStepBefore = 2 (ways para n-1)<br />
                - twoStepsBefore = 1 (ways para n-2)<br />
                - Calcular ways = oneStepBefore + twoStepsBefore
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Retornar o n√∫mero total de maneiras calculado</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre de 3 at√© n uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <!-- 13. Binary Search -->
        <div id="binary-search" class="flowchart">
          <h2>13. Binary Search</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um array de inteiros ordenado em
            ordem crescente e um valor alvo (<code>target</code>). Utilize o
            algoritmo de busca bin√°ria para encontrar o √≠ndice do alvo no array.
            Retorne <code>-1</code> caso o valor n√£o esteja presente.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso encontrar rapidamente um elemento em um array ordenado
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î VANTAGEM</h3>
              <p>
                Array est√° ordenado! Posso descartar metade dos elementos a cada
                compara√ß√£o
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üëÜ PONTEIROS</h3>
              <p>
                left = 0 (in√≠cio do array)<br />
                right = nums.length - 1 (fim do array)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Enquanto left ‚â§ right:<br />
                1. mid = (left + right) / 2<br />
                2. Comparar nums[mid] com target
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>‚ùì COMPARA√á√ÉO</h3>
              <p>
                Se nums[mid] == target ‚Üí encontrou!<br />
                Se nums[mid] < target ‚Üí left = mid + 1<br />
                Se nums[mid] > target ‚Üí right = mid - 1
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>
                Se encontrou ‚Üí retornar √≠ndice<br />
                Se n√£o encontrou ‚Üí retornar -1
              </p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(log n)</strong><br />
                Descarta metade a cada itera√ß√£o
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis auxiliares
              </div>
            </div>
          </div>
        </div>

        <!-- 14. Stock Profit -->
        <div id="stock-profit" class="flowchart">
          <h2>14. Best Time to Buy and Sell Stock</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Dado um array onde cada elemento
            representa o pre√ßo de uma a√ß√£o em um determinado dia, encontre o
            maior lucro poss√≠vel comprando em um dia e vendendo em outro
            posterior. S√≥ √© permitido realizar uma compra e uma venda.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso calcular o lucro m√°ximo comprando e vendendo uma a√ß√£o
                (comprar antes de vender)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Quero comprar no menor pre√ßo poss√≠vel e vender no maior pre√ßo
                DEPOIS disso
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üìä VARI√ÅVEIS</h3>
              <p>
                minPrice = Infinity (menor pre√ßo visto)<br />
                maxProfit = 0 (maior lucro poss√≠vel)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîÑ ITERA√á√ÉO</h3>
              <p>
                Para cada pre√ßo no array:<br />
                1. Atualizar minPrice se pre√ßo atual for menor<br />
                2. Calcular lucro se vendesse hoje<br />
                3. Atualizar maxProfit se lucro for maior
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>üí° L√ìGICA</h3>
              <p>
                A cada dia, pergunto:<br />
                "Esse √© o melhor dia para comprar?" ou<br />
                "Esse √© o melhor dia para vender?"
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Retornar o maxProfit calculado</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                Percorre o array uma vez
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>

        <!-- 15. Average Salary -->
        <div id="average-salary" class="flowchart">
          <h2>15. Average Salary Excluding Min and Max</h2>
          <div class="problem-summary">
            <strong>S√≠ntese:</strong> Receba um array de sal√°rios e calcule a
            m√©dia aritm√©tica excluindo o menor e o maior valor do array. O
            objetivo √© retornar a m√©dia dos sal√°rios intermedi√°rios, sem
            considerar os extremos.
          </div>
          <div class="flow-container">
            <div class="flow-step start">
              <h3>üéØ IN√çCIO</h3>
              <p>
                Preciso calcular a m√©dia salarial excluindo o menor e o maior
                sal√°rio
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step decision">
              <h3>ü§î ESTRAT√âGIA</h3>
              <p>
                Vou encontrar min e max, somar todos os sal√°rios, subtrair min e
                max, e dividir pelo restante
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>üîç ENCONTRAR MIN/MAX</h3>
              <p>
                minSalary = Math.min(...salary)<br />
                maxSalary = Math.max(...salary)
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚ûï SOMA TOTAL</h3>
              <p>totalSum = salary.reduce((acc, val) => acc + val, 0)</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚ûñ EXCLUIR MIN/MAX</h3>
              <p>sumWithoutMinMax = totalSum - minSalary - maxSalary</p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step process">
              <h3>‚ûó CALCULAR M√âDIA</h3>
              <p>
                count = salary.length - 2<br />
                average = sumWithoutMinMax / count
              </p>
            </div>
            <div class="arrow"></div>
            <div class="flow-step end">
              <h3>‚úÖ RESULTADO</h3>
              <p>Retornar a m√©dia calculada</p>
            </div>
          </div>
          <div class="complexity">
            <h3>üìä An√°lise de Complexidade</h3>
            <div class="complexity-grid">
              <div class="complexity-item">
                <strong>Tempo: O(n)</strong><br />
                min, max e reduce percorrem o array
              </div>
              <div class="complexity-item">
                <strong>Espa√ßo: O(1)</strong><br />
                Apenas vari√°veis extras
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      function showFlowchart(id) {
        // Esconder todos os fluxogramas
        const flowcharts = document.querySelectorAll(".flowchart");
        flowcharts.forEach((chart) => chart.classList.remove("active"));

        // Mostrar o fluxograma selecionado
        document.getElementById(id).classList.add("active");

        // Atualizar bot√µes de navega√ß√£o
        const buttons = document.querySelectorAll(".nav-btn");
        buttons.forEach((btn) => btn.classList.remove("active"));
        event.target.classList.add("active");

        // Scroll suave para o topo do conte√∫do
        document.querySelector(".content").scrollIntoView({
          behavior: "smooth",
          block: "start",
        });
      }
    </script>
  </body>
</html>
